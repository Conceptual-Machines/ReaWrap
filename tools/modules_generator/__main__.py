import logging
import textwrap

from modules_generator import TEMPLATES_DIR, AUTOGENERATED_MODULES, REAPER_TYPES
from docs_scraper import get_functions_from_docs, ReaFunc, to_snake, ReaType
from jinja2 import Environment, FileSystemLoader

from utils import get_version_from_pyproject

logger = logging.getLogger(__name__)
handler = logging.StreamHandler()
formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
handler.setFormatter(formatter)
logger.setLevel(logging.DEBUG)
logger.addHandler(handler)


ENV = Environment(loader=FileSystemLoader(TEMPLATES_DIR))
MODULE_TEMPLATE = ENV.get_template("module.jinja2")
METHOD_TEMPLATE = ENV.get_template("method.jinja2")
FUNC_CALL_TEMPLATE = ENV.get_template("function_call.jinja2")
FUNC_BODY_TEMPLATE = ENV.get_template("function_body.jinja2")
FUNC_SIGNATURE_TEMPLATE = ENV.get_template("function_signature.jinja2")


def generate_function_call(function: ReaFunc) -> str:
    """Generate a function call with the given function. This is the actual call to Reaper API."""
    reaper_name = function.rea_name
    reaper_args = []
    if function.arguments and function.arguments[0].is_reaper_type:
        reaper_args.append("self.pointer")
        args = function.arguments[1:]
    else:
        args = function.arguments
    for i, arg in enumerate(args):
        if arg.name is None:
            reaper_args.append(f"arg_{i}")
        else:
            reaper_args.append(arg.name)
    tmplt = FUNC_CALL_TEMPLATE.render(reaper_name=reaper_name, reaper_args=reaper_args)
    return tmplt


def generate_signature(function: ReaFunc, name_space: str) -> str:
    """Generate a function signature with the given function."""
    reawrap_params = []  # list of parameters to be passed to the ReaWrap class function, excluding the self pointer
    for i, arg in enumerate(function.arguments):
        if arg.is_reaper_type:
            continue
        if arg.name is None:
            name = f"arg_{i}"
        else:
            name = arg.name

        reawrap_params.append([name, arg.lua_type])
    tmplt = FUNC_SIGNATURE_TEMPLATE.render(
        reawrap_params=reawrap_params,
        reawrap_name=function.reawrap_name,
        reawrap_class=name_space,
    )
    return tmplt


def generate_function_body(function: ReaFunc, function_call: str) -> str:
    """Generate a function body with the given function call.

    :param function: ReaFunc
    :param function_call: str
    """
    return_reawrap_class, return_reawrap_class_module = None, None
    optional_params = {}
    for arg in function.arguments:
        if arg.is_optional:
            optional_params[arg.name] = arg.default_value
    return_values = []
    for i, rv in enumerate(function.return_values, start=1):
        if rv.is_reaper_type:
            return_reawrap_class = rv.lua_type
            return_reawrap_class_module = to_snake(rv.lua_type)
        if rv.name:
            return_values.append(rv.name)
        else:
            return_values.append(f"return_{i}")
    return FUNC_BODY_TEMPLATE.render(
        optional_params=optional_params,
        return_values=return_values,
        function_call=function_call,
        return_reawrap_class=return_reawrap_class,
        return_reawrap_class_module=return_reawrap_class_module,
    )


def generate_method(name_space: str, function: ReaFunc) -> str:
    """Generate a method with the given name and function."""
    function_signature = generate_signature(function, name_space)
    function_call = generate_function_call(function)
    function_body = generate_function_body(function, function_call)
    return_values = []
    # TODO improve this by passing ReaType objects to the template
    for i, rv in enumerate(function.return_values, start=1):
        if rv.name == "retval":
            continue
        if rv.is_reaper_type:
            name_and_type_ = f"{rv.lua_type} table"
        elif rv.name:
            name_and_type_ = f"{rv.name} {rv.lua_type}"
        else:
            name_and_type_ = rv.lua_type
        return_values.append(name_and_type_)
    params = []
    for i, arg in enumerate(function.arguments):
        if arg.is_reaper_type:
            continue
        if arg.name is None:
            name, type_ = f"arg_{i}", arg.lua_type
        else:
            name, type_ = arg.name, arg.lua_type
        if arg.is_optional:
            type_ = f"{type_} optional"
        params.append([name, type_])
    function_name = " ".join(function.reawrap_name.split("_")).title()
    tmplt = METHOD_TEMPLATE.render(
        function_name=function_name,
        docs=textwrap.fill(function.docs, width=80) if function.docs else "",
        params=params,
        return_values=return_values,
        function_signature=function_signature,
        function_body=function_body,
    )
    return tmplt

def generate_constructor_args(name_space: str) -> list[str]:
    """Generate constructor arguments for the given name_space / module."""
    constructor_args = {}
    match name_space:
        case "ReaProject":
            return [ReaType(name="project_idx", lua_type="number", description="The index of the project", is_optional=True, is_pointer=True)]
        case "MediaTrack":
            return [ReaType(name="pointer", lua_type="number", description="The index of the track", is_optional=True)]
    return constructor_args


def generate_module(name_space: str, functions: list[ReaFunc]) -> str:
    """Generate a module with the given name and functions."""
    methods = [generate_method(name_space, function) for function in functions]
    pointer_type = name_space if name_space in REAPER_TYPES else None
    description = f"Provide implementation for {name_space} functions"
    constructor_args = generate_constructor_args(name_space)
    module_name = to_snake(name_space)
    pversion = get_version_from_pyproject()
    tmplt = MODULE_TEMPLATE.render(
        version=pversion,
        class_name=name_space,
        module_name=module_name,
        pointer_type=pointer_type,
        description=description,
        constructor_args=constructor_args,
        methods=methods,
    )
    with open(AUTOGENERATED_MODULES / f"{module_name}.lua", "w") as f:
        f.write(tmplt)


def main():
    functions = get_functions_from_docs()
    for name_space, functions in functions.items():
        generate_module(name_space, functions)


if __name__ == "__main__":
    main()
