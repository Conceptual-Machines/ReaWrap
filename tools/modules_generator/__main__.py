import logging
import textwrap

from modules_generator import TEMPLATES_DIR, AUTOGENERATED_MODULES, REAPER_TYPES
from docs_scraper import get_functions_from_docs, ReaFunc, to_snake, ReaType
from jinja2 import Environment, FileSystemLoader

from utils import get_version_from_pyproject

logger = logging.getLogger(__name__)
handler = logging.StreamHandler()
formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
handler.setFormatter(formatter)
logger.setLevel(logging.DEBUG)
logger.addHandler(handler)


ENV = Environment(loader=FileSystemLoader(TEMPLATES_DIR))
MODULE_TEMPLATE = ENV.get_template("module.jinja2")
METHOD_TEMPLATE = ENV.get_template("method.jinja2")
FUNC_CALL_TEMPLATE = ENV.get_template("function_call.jinja2")
FUNC_BODY_TEMPLATE = ENV.get_template("function_body.jinja2")
FUNC_SIGNATURE_TEMPLATE = ENV.get_template("function_signature.jinja2")
CONSTANTS_TEMPLATE = ENV.get_template("constants.jinja2")

# These are namespaces that are not currently included in the ReaWrap module.
# Some of them may eventually be included.
# Some other may eventually be grouped under existing namespaces.
UNSUPPORTED_NAMESPACES = (
    "AudioAccessor",
    "Blink",
    "CF",
    "CSurf",
    "FNG",
    "Fab",
    "GR",
    "GSC",
    "GU",
    "JB",
    "JS",
    "LICE",
    "Llm",
    "MCULive",
    "MIDI",
    "MIDIEditor",
    "MRP",
    "ReaPack",
    "TrackCtl",
    "TrackList",
    "joystick",
    "NF",
    "SN",
    "SNM",
    "ULT",
    "Xen",
)

TRACK_FX_POINTERS = ("src_fx", "fx", "idx", "fx_idx", "index")
TAKE_FX_POINTERS = ("src_fx", "idx", "fx_idx", "index")


def generate_function_call_args_by_name_space(
    function: ReaFunc, namespace: str
) -> list[str]:
    """Generate function call arguments for the given function by namespace."""
    reaper_args = []
    match namespace:
        case "TrackFX":
            for i, arg in enumerate(function.arguments):
                if arg.lua_type in ("MediaTrack", "MediaItemTake"):
                    if i == 0:
                        # the first argument corresponds to the attribute TrackFX.track so in the call to Reaper API
                        # we pass the pointer to the track
                        reaper_args.append("self.track.pointer")
                    else:
                        reaper_args.append(f"{arg.name}.pointer")

                elif arg.name in TRACK_FX_POINTERS:
                    if function.reawrap_name == "set_preset_by_index" and arg.name == "idx":
                        # pointer false positive, we need to pass the preset index instead
                        reaper_args.append("preset_idx")
                    else:
                        reaper_args.append("self.pointer")
                else:
                    reaper_args.append(arg.name)
        case "TakeFX":
            for i, arg in enumerate(function.arguments):
                if arg.lua_type in ("MediaTrack", "MediaItemTake"):
                    if i == 0:
                        # the first argument corresponds to the attribute TakeFX.take so in the call to Reaper API
                        # we pass the pointer to the take
                        reaper_args.append("self.take.pointer")
                    else:
                        reaper_args.append(f"{arg.name}.pointer")
                elif arg.name in TAKE_FX_POINTERS:
                    reaper_args.append(f"self.pointer")
                else:
                    reaper_args.append(arg.name)
    return reaper_args


def generate_function_call_args(function, namespace):
    """Generate function call arguments for the given function."""
    reaper_args = []
    first_arg = function.arguments[0] if function.arguments else None
    if function.arguments and first_arg.is_reaper_type:
        if first_arg.lua_type != namespace:
            reaper_args.append(f"self.{first_arg.name}.pointer")
        else:
            reaper_args.append("self.pointer")
        args = function.arguments[1:]
    else:
        args = function.arguments
    for i, arg in enumerate(args):
        if arg.name is None:
            reaper_args.append(f"arg_{i}")
        else:
            reaper_args.append(arg.name)
    return reaper_args


def generate_function_call(function: ReaFunc, namespace: str) -> str:
    """Generate a function call with the given function. This is the actual call to Reaper API."""
    reaper_name = function.rea_name
    if namespace in ("TrackFX", "TakeFX"):
        # TrackFX and TakeFX arguments need to be handled differently
        reaper_args = generate_function_call_args_by_name_space(function, namespace)
    else:
        reaper_args = generate_function_call_args(function, namespace)
    tmplt = FUNC_CALL_TEMPLATE.render(reaper_name=reaper_name, reaper_args=reaper_args)
    return tmplt


def generate_signature_params_by_name_space(
    function: ReaFunc, namespace: str
) -> list[ReaType]:
    """Generate signature parameters for the given function by namespace."""
    reawrap_params = []  # list of parameters to be passed to the ReaWrap class function signature, excluding pointer arguments
    match namespace:
        case "TrackFX":
            for i, arg in enumerate(function.arguments):
                if arg.name is None:
                    arg.name = f"arg_{i}"
                # skipping the first argument cause it corresponds to the attribute TrackFX.track
                elif i == 0 and arg.lua_type == "MediaTrack":
                    continue
                if function.reawrap_name == "set_preset_by_index" and arg.name == "idx":
                    reawrap_params.append(
                        ReaType(
                            name="preset_idx",
                            lua_type="number",
                            description="The index of the preset",
                        )
                    )
                # skipping any argument that corresponds to the FX index, i.e. the attribute TrackFX.pointer
                elif arg.name in TRACK_FX_POINTERS:
                    continue
                else:
                    reawrap_params.append(arg)

        case "TakeFX":
            for i, arg in enumerate(function.arguments):
                if arg.name is None:
                    arg.name = f"arg_{i}"
                # skipping the first argument cause it corresponds to the attribute TakeFX.take
                elif i == 0 and arg.lua_type == "MediaItemTake":
                    continue
                # skipping any argument that corresponds to the FX index, i.e. the TakeFX.pointer
                elif arg.name in TAKE_FX_POINTERS:
                    continue
                else:
                    reawrap_params.append(arg)
    return reawrap_params


def generate_signature_params(function: ReaFunc) -> list[[ReaType]]:
    reawrap_params = []  # list of parameters to be passed to the ReaWrap class function, excluding the self pointer
    for i, arg in enumerate(function.arguments):
        # skipping the first argument cause it corresponds to the self.pointer
        if arg.is_reaper_type:
            continue
        if arg.name is None:
            arg.name = f"arg_{i}"

        reawrap_params.append(arg)
    return reawrap_params


def generate_signature(
    reawrap_name: str, reawrap_params: list[ReaType], name_space: str
) -> str:
    """Generate a function signature with the given function."""
    tmplt = FUNC_SIGNATURE_TEMPLATE.render(
        reawrap_params=reawrap_params,
        reawrap_name=reawrap_name,
        reawrap_class=name_space,
    )
    return tmplt


def generate_function_body(function: ReaFunc, function_call: str) -> str:
    """Generate a function body with the given function call.

    :param function: ReaFunc
    :param function_call: str
    """
    return_reawrap_class, return_reawrap_class_module = None, None
    optional_params = {}
    for arg in function.arguments:
        if arg.is_optional:
            optional_params[arg.name] = arg.default_value
    return_values = []
    for i, rv in enumerate(function.return_values, start=1):
        if rv.is_reaper_type:
            return_reawrap_class = rv.lua_type
            return_reawrap_class_module = to_snake(rv.lua_type)
        if rv.name:
            return_values.append(rv.name)
        else:
            return_values.append(f"return_{i}")
    return FUNC_BODY_TEMPLATE.render(
        optional_params=optional_params,
        return_values=return_values,
        function_call=function_call,
        return_reawrap_class=return_reawrap_class,
        return_reawrap_class_module=return_reawrap_class_module,
    )


def generate_method(name_space: str, function: ReaFunc) -> str:
    """Generate a method with the given name and function."""
    if name_space in ("TrackFX", "TakeFX"):
        reawrap_params = generate_signature_params_by_name_space(function, name_space)
    else:
        reawrap_params = generate_signature_params(function)
    function_signature = generate_signature(
        function.reawrap_name, reawrap_params, name_space
    )
    function_call = generate_function_call(function, name_space)
    function_body = generate_function_body(function, function_call)
    return_values = []
    # TODO improve this by passing ReaType objects to the template
    for i, rv in enumerate(function.return_values, start=1):
        if rv.name == "retval":
            continue
        if rv.is_reaper_type:
            name_and_type_ = f"{rv.lua_type} table"
        elif rv.name:
            name_and_type_ = f"{rv.name} {rv.lua_type}"
        else:
            name_and_type_ = rv.lua_type
        return_values.append(name_and_type_)

    function_name = " ".join(function.reawrap_name.split("_")).title()
    tmplt = METHOD_TEMPLATE.render(
        function_name=function_name,
        docs=textwrap.fill(function.docs, width=80) if function.docs else "",
        params=reawrap_params,
        return_values=return_values,
        function_signature=function_signature,
        function_body=function_body,
    )
    return tmplt


def generate_constants(name: str, reawrap_name: str, constants: list[ReaType]) -> str:
    """Generate a constants table with the given constants."""
    return CONSTANTS_TEMPLATE.render(
        name=name, reawrap_name=reawrap_name, constants=constants
    )


def generate_constructor_args(name_space: str) -> list[ReaType]:
    """Generate constructor arguments for the given name_space / module."""
    constructor_args = {}
    match name_space:
        case "ReaProject":
            return [
                ReaType(
                    name="project_idx",
                    lua_type="number",
                    description="The index of the project",
                    is_optional=True,
                    is_pointer=True,
                )
            ]
        case "MediaTrack":
            return [
                ReaType(
                    name="media_track",
                    lua_type="userdata",
                    description="The pointer to Reaper MediaTrack*",
                    is_pointer=True,
                )
            ]
        case "MediaItem":
            return [
                ReaType(
                    name="media_item",
                    lua_type="userdata",
                    description="The pointer to Reaper MediaItem*",
                    is_pointer=True,
                )
            ]
        case "MediaItemTake":
            return [
                ReaType(
                    name="take",
                    lua_type="userdata",
                    description="The pointer to Reaper MediaItem_Take*",
                    is_pointer=True,
                )
            ]
        case "TrackEnvelope":
            return [
                ReaType(
                    name="envelope",
                    lua_type="userdata",
                    description="The pointer to Reaper TrackEnvelope*",
                    is_pointer=True,
                )
            ]
        case "TrackFX":
            return [
                ReaType(
                    name="track",
                    lua_type="MediaTrack",
                    description="The MediaTrack object",
                ),
                ReaType(
                    name="fx_idx",
                    lua_type="number",
                    description="The index of the FX",
                    is_pointer=True,
                ),
            ]
        case "TakeFX":
            return [
                ReaType(
                    name="take",
                    lua_type="MediaItemTake",
                    description="The MediaItemTake object",
                ),
                ReaType(
                    name="fx_idx",
                    lua_type="number",
                    description="The index of the FX",
                    is_pointer=True,
                ),
            ]
        case "PCM":
            return [
                ReaType(
                    name="source",
                    lua_type="userdata",
                    description="The pointer to PCM_source*",
                    is_pointer=True,
                )
            ]
        case "AudioAccessor":
            return [
                ReaType(
                    name="audio_accessor",
                    lua_type="userdata",
                    description="The pointer to audio accessor",
                    is_pointer=True,
                )
            ]
    return constructor_args


def get_dependencies(name_space: str, functions: list[ReaFunc]) -> list[str]:
    """Get dependencies for the given name_space."""
    dependencies = {"helpers"}
    for function in functions:
        for arg in function.arguments:
            if arg.is_reaper_type and arg.lua_type != name_space:
                dependencies.add(to_snake(arg.lua_type))
    return list(sorted(dependencies))


def generate_module(name_space: str, functions: list[ReaFunc]) -> str:
    """Generate a module with the given name and functions.
    Some modules have been renamed from the original name space for convenience.

    :param name_space: str The name_space of the module.
    :param functions: list[ReaFunc]
    """
    methods = []
    for function in functions:
        if function.constants:
            constant_name = (
                f"{name_space}."
                + "".join([p.title() for p in function.reawrap_name.split("_")])
                + "Constants"
            )
            reawrap_name = f"{name_space}:{function.reawrap_name}"
            constants = generate_constants(
                constant_name, reawrap_name, function.constants
            )
            methods.append(constants)
            for arg in function.arguments:
                # the first string argument is mapped to constants
                if arg.lua_type == "string":
                    arg.description = constant_name
                    break

            method = generate_method(name_space, function)
            methods.append(method)
        else:
            method = generate_method(name_space, function)
            methods.append(method)
    dependencies = get_dependencies(name_space, functions)
    pointer_type = f"{name_space}*" if name_space in REAPER_TYPES else None
    if name_space == "MediaItemTake":
        pointer_type = "MediaItem_Take*"
    description = f"Provide implementation for {name_space} functions"
    constructor_args = generate_constructor_args(name_space)
    module_name = to_snake(name_space)
    pversion = get_version_from_pyproject()
    has_optional_args = any(arg.is_optional for arg in constructor_args)
    tmplt = MODULE_TEMPLATE.render(
        version=pversion,
        dependencies=dependencies,
        class_name=name_space,
        module_name=module_name,
        pointer_type=pointer_type,
        description=description,
        constructor_args=constructor_args,
        methods=methods,
        has_optional_args=has_optional_args,
    )
    with open(AUTOGENERATED_MODULES / f"{module_name}.lua", "w") as f:
        f.write(tmplt)
    logger.info(f"Generated module: {module_name}.lua")


def main():
    AUTOGENERATED_MODULES.mkdir(exist_ok=True)
    functions = get_functions_from_docs()
    for name_space, functions in functions.items():
        if name_space in UNSUPPORTED_NAMESPACES:
            logger.info(
                f"Skipping unsupported namespace: {name_space}",
            )
            continue

        generate_module(name_space, functions)


if __name__ == "__main__":
    main()
